<!DOCTYPE html>
<html>

<head>
	<title>AI Chess PGN Analyzer</title>
</head>

<body style="margin: 0; padding: 0; height: 100vh; width: 100vw; overflow: hidden; display: flex; flex-direction: column; font-family: sans-serif;">

	<header style="height: 50px; background: #333; color: white; display: flex; align-items: center; padding: 0 20px; flex-shrink: 0;">
		<h1>AI Chess PGN Analyzer</h1>
	</header>

	<main style="display: flex; height: calc(100vh - 80px); overflow: hidden;">

		<div id="board-area" style="flex: 6; background: #eee; display: flex; flex-direction: column; justify-content: center; align-items: center; padding: 10px; min-height: 0">
			<div id="board" style="width: 100%; max-width: 450px;"></div>
		</div>

		<div id="analysis-area" style="flex: 4; display: flex; flex-direction: column; padding: 20px; border-left: 1px solid #ccc; background: white; height: 100%; box-sizing: border-box;">

			<div id="results" style="display: flex; flex-direction: column; flex-grow: 1;">
				<div id="ai-review" style="height: 30%; min-height: 100px; padding: 15px; background: #f9f9f9; border-bottom: 2px solid #eee; overflow-y: auto;">
					<p style="color: #888;">AI analysis for each move will appear here...</p>
				</div>

				<div id="pgn" style="flex-grow: 1; overflow-y: auto; border-top: 1px solid #eee; padding-top: 10px;">
					<p style="color: #888;">Moves will appear here...</p>
				</div>
				<div id="nav-controls" style="display: flex; gap: 5px; margin-bottom: 10px;">
				    <button onclick="jumpTo(0)" style="flex: 1; padding: 5px; cursor: pointer;">|&lt;</button>
				    <button onclick="step(-1)" style="flex: 1; padding: 5px; cursor: pointer;">&lt;</button>
				    <button onclick="step(1)" style="flex: 1; padding: 5px; cursor: pointer;">&gt;</button>
				    <button onclick="jumpTo(analysisResults.length - 1)" style="flex: 1; padding: 5px; cursor: pointer;">&gt;|</button>
				</div>
			</div>

			<div id="controls">
				<textarea id="pgn-input" placeholder="Paste PGN here..." style="width: 100%; height: 50px; padding: 8px; resize: none; box-sizing: border-box;"></textarea>
    			<div style="display: flex; align-items: center; justify-content: space-between; gap: 10px; margin-top: 10px;">
        			<div style="flex: 3;">
            			<label style="font-size: 11px; font-weight: bold; display: block;">DEPTH: <span id="depth-value">8</span></label>
            			<input type="range" id="depth-slider" min="1" max="20" value="8" style="width: 100%; accent-color: #4CAF50;">
        			</div>
        			<div style="text-align: center; flex: 0.8;">
            		<div id="color-btn" style="width: 35px; height: 35px; border-radius: 50%; border: 3px solid #4CAF50; margin: 0 auto; cursor: pointer; background: white;"></div>
            			<span id="color-name" style="font-size: 9px; font-weight: bold; text-align: center;">I'm White</span>
        			</div>
        			<button id="analyze-btn" style="flex: 1.4; padding: 10px; cursor: pointer; background: #4CAF50; color: white; border: none; font-weight: bold; border-radius: 4px;">
            			ANALYZE GAME
        			</button>
				</div>
			</div>
		</div>

	</main>

	<footer style="height: 30px; background: #444; color: white; font-size: 0.8rem; display: flex; align-items: center; justify-content: center; flex-shrink: 0;">
		<p style="text-align: center;">&copy; 2025 cHamster24. All rights reserved. | <a
				href="https://github.com/chamster24/chess-pgn-analysis/">Github</a></p>
	</footer>

	<link rel="stylesheet" href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css">
	<script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
	<script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
	<script>
		const game = new Chess();
		const engine = new Worker('stockfish.js');

		const color_btn = document.getElementById('color-btn');
		const color_name = document.getElementById('color-name');
		const depth_slider = document.getElementById('depth-slider');
		const depthLabel = document.getElementById('depth-value');
		const analyze_btn = document.getElementById('analyze-btn');
		const board = ChessBoard('board', {
			position: 'start',
			pieceTheme: 'https://chessboardjs.com/img/chesspieces/wikipedia/{piece}.png'
		});

		let engineReady = false;
		let currentMoveIndex = 0;
		let analysisResults = []; // This will store the JSON for the AI
		let analysisPositions = [];
		let gameHeaders = {};
		let latestScoredCP = 0;
		let gotScoreForMove = false;
		let retryCount = 0;

		const ratingMap = {
			1: { ico: "!!", txt: "Brilliant", col: "#22c9a8" },
			2: { ico: "â­", txt: "Best", col: "#57ad42" },
			3: { ico: "ðŸ‘", txt: "Excellent", col: "#63ad4b" },
			4: { ico: "âœ…", txt: "Good", col: "#7ec961" },
			5: { ico: "?!", txt: "Inaccuracy", col: "#ebc634" },
			6: { ico: "?", txt: "Mistake", col: "#eb7a34" },
			7: { ico: "??", txt: "Blunder", col: "#e0201d" }
		};

		// Color Picker Button Code
		let userColor = "w";
		color_btn.onclick = function() {
			if (userColor === "w") {
				userColor = "b";
				color_btn.style.backgroundColor = 'black';
				color_name.innerText = "I'm black";
			} else {
				userColor = "w";
				color_btn.style.backgroundColor = 'white';
				color_name.innerText = "I'm white";
			}
			console.log("User changed color to:", userColor)
		}

		function jumpTo(index) {
		    if (analysisResults.length === 0) return;
		    
		    // Ensure index is within 0 and the last move
		    currentMoveIndex = Math.max(0, Math.min(index, analysisResults.length - 1));
		    updateMoveView();
		}
		
		function step(delta) {
		    if (analysisResults.length === 0) return;
		    
		    let newIndex = currentMoveIndex + delta;
		    jumpTo(newIndex);
		}
		function updateMoveView() {
		    if (!analysisResults || analysisResults.length === 0) return;
		
		    const move = analysisResults[currentMoveIndex];
		    const r = ratingMap[move.c.AIRATE] || { txt: "Analysis", col: "#666", ico: "" };
		
		    // Update Board
		    board.position(analysisPositions[currentMoveIndex]);
		
		    // Logic: Only show Engine Suggestion if the move was NOT the best or brilliant (AIRATE 1 or 2)
		    const isNotBest = move.c.AIRATE > 2;
		
		    const reviewBox = document.getElementById('ai-review');
		    reviewBox.innerHTML = `
		        <div style="border-left: 6px solid ${r.col}; padding: 15px; background: white; border-radius: 0 8px 8px 0; box-shadow: 0 2px 4px rgba(0,0,0,0.05);">
		            <h3 style="margin: 0 0 8px 0; font-size: 1.1rem; color: #333;">
		                ${move.san} is <span style="color: ${r.col};">${r.ico} ${r.txt}</span>
		            </h3>
		            <p style="margin: 0; color: #444; line-height: 1.5; font-size: 0.95rem;">
		                ${move.c.AICOMM}
		            </p>
		            ${(isNotBest && move.bm) ? `
		                <div style="margin-top: 12px; padding-top: 8px; border-top: 1px solid #eee; font-size: 0.85rem; color: #777;">
		                    Engine Suggestion: <span style="color: #57ad42; font-weight: bold;">${move.bm}</span>
		                </div>
		            ` : ""}
		        </div>
		    `;
		    // Refresh move list to update the "active" move highlighting
		    generateMoveList();
		}

		function generateMoveList() {
		    const pgnContainer = document.getElementById('pgn');
		    let html = '<div style="display: flex; flex-wrap: wrap; gap: 10px; padding: 5px;">';
		
		    analysisResults.forEach((move, index) => {
		        const r = ratingMap[move.c.AIRATE] || { ico: "", col: "transparent" };
		        const isWhite = move.m.includes('w');
		        
		        if (isWhite) {
		            html += `<span style="color: #888; font-weight: bold; margin-right: 2px;">${Math.floor(index/2) + 1}.</span>`;
		        }
		
		        // Create a "hyperlink" using a span with a click event
		        html += `
		            <span onclick="jumpTo(${index})" style="cursor: pointer; font-weight: ${currentMoveIndex === index ? 'bold' : 'normal'}; color: ${currentMoveIndex === index ? '#4CAF50' : '#333'}; padding: 2px 4px; border-radius: 3px; background: ${currentMoveIndex === index ? '#e8f5e9' : 'transparent'};">
		                ${move.san}<span style="color: ${r.col}; font-size: 0.8rem; margin-left: 2px; vertical-align: super;">${r.ico}</span>
		            </span>
		        `;
		    });
		
		    html += '</div>';
		    pgnContainer.innerHTML = html;
		}

		
		function analizegame() {
			// Reset engine state
			currentMoveIndex = 0;
			const history = game.history({ verbose: true });
			const tempGame = new Chess(); 
    		analysisPositions = [];

			// Create the empty slots for scores
			analysisResults = history.map((move, index) => {
				tempGame.move(move); // Move the temp board forward
        		analysisPositions.push(tempGame.fen()); // Store the FULL FEN string
				
				const moveNum = Math.floor(index / 2) + 1;
				const side = move.color === 'w' ? 'w' : 'b';
				// Look for [%clk 0:00:00] in the move comments
				let timestamp = "";
				if (move.comments) {
					const clkMatch = move.comments.join(" ").match(/\[%clk\s+([\d:]+)\]/);
					timestamp = clkMatch ? clkMatch[1] : "";
				}

				let originalComments = "";
				if (move.comments) {
					originalComments = move.comments
						.join(" ")
						.replace(/\[%clk\s+[\d:]+\]/g, "") // Strip the clock tag
						.trim();
				}
				return {
					m: `${moveNum}${side}`,
					san: move.san,
					cp: 0,   // This will be filled by engine
					pcp: 0,  // This will be filled by engine
					t: timestamp,
					bm: "",
					c: {
						AIRATE: "", // This will be filled by ai
						AICOMM: "", // This will be filled by ai
						COMM: originalComments, // This will be filled by engine
					}
				};
			});

			//analysisPositions = history.map(m => m.after); //commented for debug
			engine.postMessage("ucinewgame");
			engine.postMessage("isready");
			analyzeNextPosition();
		}

		function analyzeNextPosition() {
			if (currentMoveIndex >= analysisPositions.length) {
				callGemini(analysisResults);
				return;
			}
			
			const fen = analysisPositions[currentMoveIndex];
			const depth = depth_slider.value;
			gotScoreForMove = false;
			
			// DEBUG - uncomment next line
			// console.log("Analyzing FEN:", fen);
			
			document.getElementById('ai-review').innerHTML = `Analyzing move ${currentMoveIndex + 1}...`;

			engine.postMessage(`stop`);
			engine.postMessage(`position fen ${fen}`);
			if (retryCount > 0) {
				engine.postMessage(`go depth ${depth} movetime 1000`);
			} else {
				engine.postMessage(`go depth ${depth}`);
			}
		}
		// Update the number for slider moves
		depth_slider.oninput = function () {
			depthLabel.innerHTML = this.value;
		};

		// recieves messages from stockfish
		engine.postMessage('uci');

		engine.onmessage = function (event) {
			const line = event.data;
			// DEBUG - uncomment next line
			console.log("SF:", line);

			if (line === "uciok") {
				engineReady = true;
				console.log("Engine is Ready");
			}

			// 1. Capture the latest evaluation
			if (line.includes("info") && line.includes("score")) {
				const parts = line.split(" ");
				if (analysisPositions[currentMoveIndex] && line.includes("cp")) {
					const cpIndex = parts.indexOf("cp");
					latestScoredCP = parseInt(parts[cpIndex + 1]);
					const currentFen = analysisPositions[currentMoveIndex];
					if (currentFen.includes(" b ")) {
						latestScoredCP = -latestScoredCP;
					}
					gotScoreForMove = true;
					console.log("Caught CP:", latestScoredCP);
				} else if (line.includes("mate")) {
					const parts = line.split(" "); // Re-declaring parts for the mate line
					const mateIndex = parts.indexOf("mate");
					const mateValue = parseInt(parts[mateIndex + 1]);
					latestScoredCP = mateValue > 0 ? 10000 : -10000;
					gotScoreForMove = true;
				}
			}
		
			// 2. Only move forward when Stockfish says it's done
			if (line.startsWith("bestmove")) {
				if (gotScoreForMove === false && retryCount < 1) {
					console.log(`No score line caught. Retrying...`);
					retryCount++;
					analyzeNextPosition(); 
					return;
				}

				const moveParts = line.split(" ");
			    analysisResults[currentMoveIndex].bm = moveParts[1]; // Grabs "e2e4" from "bestmove e2e4"
			
			    analysisResults[currentMoveIndex].cp = latestScoredCP;
			    if (currentMoveIndex + 1 < analysisResults.length) {
			        analysisResults[currentMoveIndex + 1].pcp = latestScoredCP;
			    }

				console.log(`Move ${analysisResults[currentMoveIndex].m}: ${latestScoredCP}`);
				currentMoveIndex++;
				if (currentMoveIndex < analysisPositions.length) {
					retryCount = 0;
					gotScoreForMove = false;
					analyzeNextPosition();
				} else {
					document.getElementById('ai-review').innerHTML = "<b>Stockfish Complete!</b> Sending to Gemini for Analysis...";
					callGemini(analysisResults);
				}
			}
		}; 

		// Check for valid PGN on button click, before running a game check
		analyze_btn.addEventListener('click', function () {
			const pgnText = document.getElementById('pgn-input').value;
			const isValid = game.load_pgn(pgnText);
			board.position(game.fen());
			if (!isValid) {
				alert("Invalid PGN!")
			} else {
				if (!engineReady === true) {
					alert("Error with stockfish. Please wait - it may still be loading.")
				} else {
					analizegame();
				}
			}
		});

		async function callGemini(fullGameData) {
			document.getElementById('ai-review').innerHTML = "AI is thinking...";

			try {
				const vercelUrl = 'https://chess-pgn-analysis.vercel.app/api';

				const payload = {
					playerColor: userColor,
					gameData: fullGameData
				}

				// 2. Send the chess data to the Python function
				const response = await fetch(vercelUrl, {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify(payload)
				});

				const result = await response.json();

				// 3. Error check: see if Python or Gemini had a problem
				if (result.error) {
					document.getElementById('ai-review').innerHTML = `<b>Backend Error:</b> ${result.error}`;
					return;
				}
				analysisResults = result; // Save the AI-enhanced data
				currentMoveIndex = 0;     // Reset to move 1
				updateMoveView();         // Update the review box
				// 4. Get the text from the Gemini response format

        console.log("Success! Full Data:", analysisResults);
			} catch (error) {
				console.error("Connection Error:", error);
				document.getElementById('ai-review').innerHTML = "Could not reach Python backend. Check console.";
			}
		}
	</script>
</body>

</html>
